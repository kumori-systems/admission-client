/**
 * ECloud Admission
 * The Admission API is the entry point for ECloud users to interact with the system. With this API you can perform operations such as registering components, services, deploying them, checking their status, etc.  In order to correctly understand the terms used in descriptions of API elements, it is necessary to have some knowledge about the structure of the services within the ECloud PAAS. Information on this topic can be found in the ECloud manual.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import Axios from 'axios';
import {AxiosResponse, AxiosRequestConfig} from 'axios'
import FormData = require('form-data');

let defaultBasePath = 'http://admission.argo.kumori.cloud/admission';

/* tslint:disable:no-unused-variable */

export class Deployment {
    'service': string;
    'roles': { [key: string]: InlineResponse2001Roles; };
}

export class DeploymentRole {
    'instances': { [key: string]: InlineResponse2001Instances; };
}

export class GeneralResponse {
    'success': boolean;
    'message': string;
    'data': any;
}

export class InlineResponse200 {
    'success': boolean;
    'message': string;
    'data': InlineResponse200Data;
}

export class InlineResponse2001 {
    'success': boolean;
    'message': string;
    'data': { [key: string]: InlineResponse2001Data; };
}

export class InlineResponse2001Arrangement {
    'cpu': number;
    'bandwidth': number;
    'failurezones': number;
    'mininstances': number;
    'maxinstances': number;
}

export class InlineResponse2001Data {
    'service': string;
    'roles': { [key: string]: InlineResponse2001Roles; };
}

export class InlineResponse2001Instances {
    'id': string;
    'privateIp': string;
    'publicIp': string;
    'arrangement': InlineResponse2001Arrangement;
}

export class InlineResponse2001Roles {
    'instances': { [key: string]: InlineResponse2001Instances; };
}

export class InlineResponse2002 {
    'success': boolean;
    'message': string;
    'data': any;
}

export class InlineResponse200Data {
    'successful': any;
    'errors': any;
    'deployments': any;
    'links': any;
    'tests': any;
    'testToken': string;
}

export class InstanceInfo {
    'id': string;
    'privateIp': string;
    'publicIp': string;
    'arrangement': InlineResponse2001Arrangement;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: any): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: any): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: any): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: any): void {
        // Do nothing
    }
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiAuthorization': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set accessToken(token: string) {
        this.authentications.apiAuthorization.accessToken = token;
    }


    /**
     * 
     * Registers a set of bundles in the system. At least one of the parameters must have a proper value.
     * @param bundlesZip A zip with a set of bundles, each one of them in a different folder. The structure of a bundle is documented in ECloud SDK manual, section 4.1.
     * @param bundlesJson A Json file with a list of references to bundles. The format of this file must follow the specification in the ECloud SDK manual, section 4.1.1.
     */
    public bundlesPost (bundlesZip?: any, bundlesJson?: any) : 
        Promise<InlineResponse200> {
      const localVarPath = this.basePath + '/bundles';
      let queryParameters: any = {};
      //let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams;

      const fd:FormData = new FormData();
      formParams = fd;

      if (bundlesZip !== undefined) {
          fd.append('bundlesZip', bundlesZip, 'bundle.zip');
      }
      if (bundlesJson !== undefined) {
          fd.append('bundlesJson', bundlesJson, 'bundle.json');
      }
  
      let requestOptions: AxiosRequestConfig = {
          method: 'POST',
          params: queryParameters,
          headers: fd.getHeaders(),
          url: localVarPath,
          data:formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

      // console.log(JSON.stringify(requestOptions.headers,null,2));

      const deferred:Deferred<InlineResponse200> = new Deferred<InlineResponse200>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }

    /**
     * 
     * Undeploys a deployment in the system.
     * @param urn Urn of deployment to be undeployed
     */
    public deploymentsDelete (urn: string) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/deployments';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);

      // verify required parameter 'urn' is not null or undefined
      if (urn === null || urn === undefined) {
        throw new Error('Required parameter urn was null or undefined when calling deploymentsDelete.');
      }

      if (urn !== undefined) {
        queryParameters['urn'] = urn;
      }

      let requestOptions: AxiosRequestConfig = {
        method: 'DELETE',
        params: queryParameters,
        headers: headerParams,
        url: localVarPath
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);
       
     const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }
    /**
     * 
     * Performs a new deployment in the system.
     * @param inline The uploaded deployment file following specification in ECloud Manual, section 4.
     */
    public deploymentsPost (inline: File) : Promise<InlineResponse2001> {
      const localVarPath = this.basePath + '/deployments';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams: FormData = new FormData();

      // verify required parameter 'inline' is not null or undefined
      if (inline === null || inline === undefined) {
          throw new Error('Required parameter inline was null or undefined when calling deploymentsPost.');
      }

      if (inline !== undefined) {
          formParams.append('inline', inline, inline.name);
      }

      let requestOptions:AxiosRequestConfig = {
        method: 'POST',
        params: queryParameters,
        headers: headerParams,
        url: localVarPath,
        data: formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);
      
      const deferred:Deferred<InlineResponse2001> = new Deferred<InlineResponse2001>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }

    /**
     * 
     * Returns data of deployed services in system.
     * @param urn urn of deployment whose data is needed. If not provided, data about any accesible deployment is returned.
     * @param owner Only the deployments whose owner matches the value of the parameter are listed
     * @param show Desired format of the information provided for each deployment. Possible values are&amp;#58; * topology. It is the default value. * extended. * urn. Only urns are listed.
     */
    public findDeployments (urn?: string, owner?: string, show?: string) : 
        Promise<InlineResponse2001> {
      const localVarPath = this.basePath + '/deployments';
      const queryParameters: any = {};
      const headerParams: any = (<any>Object).assign({}, this.defaultHeaders);

      if (urn !== undefined) {
          queryParameters['urn'] = urn;
      }

      if (owner !== undefined) {
          queryParameters['owner'] = owner;
      }

      if (show !== undefined) {
          queryParameters['show'] = show;
      }

      const requestOptions:AxiosRequestConfig = {
          method: 'get',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath,
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2001> = new Deferred<InlineResponse2001>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }

    /**
     * 
     * Removes a link between two services
     * @param linkManifest The manifest of the link to be removed.
     */
    public linksDelete (linkManifest: Buffer) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/links';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams: any = {};


      // verify required parameter 'linkManifest' is not null or undefined
      if (linkManifest === null || linkManifest === undefined) {
        throw new Error('Required parameter linkManifest was null or undefined when calling linksDelete.');
      }

      let useFormData = false;

      if (linkManifest !== undefined) {
        formParams['linkManifest'] = linkManifest;
      }
      useFormData = true;

      let requestOptions: AxiosRequestConfig = {
        method: 'DELETE',
        params: queryParameters,
        headers: headerParams,
        url: localVarPath,
        data: formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }


    /**
     * 
     * Creates a new link between two deployed services.
     * @param linkManifest The manifest of the desired link.
     */
    public linksPost (linkManifest: Buffer) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/links';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams: any = {};

      // verify required parameter 'linkManifest' is not null or undefined
      if (linkManifest === null || linkManifest === undefined) {
          throw new Error('Required parameter linkManifest was null or undefined when calling linksPost.');
      }

      if (linkManifest !== undefined) {
          formParams['linkManifest'] = linkManifest;
      }

      let requestOptions: AxiosRequestConfig = {
          method: 'POST',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath,
          data:formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;

    }
    /**
     * 
     * Modification of some parameter of the deployment.      There are two possible actions&amp;#58; * Reconfiguration of parameters or deployment and * Manual scaling.
     * @param inline The uploaded deployment file with the new configuration. The file must be a JSON with this keys&amp;#58; * deploymentURN. URN of the deployment to be reconfigured. * action. manualScaling/reconfig * entryPoints (only when reconfig action) * configuration (only when reconfig action) * roles (only when manualScaling action)
     */
    public modifyDeployment (inline: Buffer) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/deployments/configuration';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams: any = {};


      // verify required parameter 'inline' is not null or undefined
      if (inline === null || inline === undefined) {
          throw new Error('Required parameter inline was null or undefined when calling modifyDeployment.');
      }

      if (inline !== undefined) {
          formParams['inline'] = inline;
      }

      let requestOptions: AxiosRequestConfig = {
          method: 'PUT',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath,
          data: formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }
    /**
     * 
     * Returns data of registered entities in the system. These can be component, services, runtimes and resources.
     * @param urn urn of deployment whose data is needed. If not provided, data about any accesible deployment is returned.
     */
    public registriesGet (urn?: string) : Promise<InlineResponse2002> {
      let localVarPath = this.basePath + '/registries';
      const queryParameters: any = {};
      const headerParams: any = (<any>Object).assign({}, this.defaultHeaders);

      if (urn !== undefined) {
        localVarPath = localVarPath + '/' + encodeURIComponent(urn)
      }

      const requestOptions:AxiosRequestConfig = {
          method: 'GET',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2001> = new Deferred<InlineResponse2001>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }

    /**
     * 
     * Remove a registered entity based on its urn.
     * @param urn The urn of registered entity to be deleted.
     */
    public registriesUrnDelete (urn: string) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/registries';
      let queryParameters: any = {'urn': urn};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);

      // verify required parameter 'urn' is not null or undefined
      if (urn === null || urn === undefined) {
          throw new Error('Required parameter urn was null or undefined when calling registriesUrnDelete.');
      }

      let requestOptions: AxiosRequestConfig = {
          method: 'DELETE',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath,
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);

      this.authentications.default.applyToRequest(requestOptions);

     const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }

    /**
     * 
     * Returns manifest of a registered entity based on its urn.
     * @param urn The urn of registered entity to get its manifest .
     */
    public registriesUrnGet (urn: string) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/registries/{urn}'
          .replace('{' + 'urn' + '}', String(urn));
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams: any = {};


      // verify required parameter 'urn' is not null or undefined
      if (urn === null || urn === undefined) {
          throw new Error('Required parameter urn was null or undefined when calling registriesUrnGet.');
      }

      let requestOptions: AxiosRequestConfig = {
          method: 'GET',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath,
          data: formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);
      this.authentications.default.applyToRequest(requestOptions);

     const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }
    /**
     * 
     * Modifies the number of instances of some role of a deployment
     * @param inline 
     */
    public scaleInstances (inline: Buffer) : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/deployments/instances';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
      let formParams: any = {};

      // verify required parameter 'inline' is not null or undefined
      if (inline === null || inline === undefined) {
          throw new Error('Required parameter inline was null or undefined when calling scaleInstances.');
      }

      if (inline !== undefined) {
          formParams['inline'] = inline;
      }

      let requestOptions: AxiosRequestConfig = {
          method: 'PUT',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath,
          data: formParams
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);
      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }
    /**
     * 
     * Removes a test context
     * @param urn Identifier of the test context to be removed.
     */
    public testContextsDelete (urn: string) : Promise<InlineResponse2002> {
        const localVarPath = this.basePath + '/test-contexts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'urn' is not null or undefined
        if (urn === null || urn === undefined) {
            throw new Error('Required parameter urn was null or undefined when calling testContextsDelete.');
        }

        if (urn !== undefined) {
            queryParameters['urn'] = urn;
        }

        let requestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: queryParameters,
            headers: headerParams,
            url: localVarPath,
            data: formParams
        };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);
      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }
    /**
     * 
     * List current test contexts in the stamp.
     */
    public testContextsGet () : Promise<InlineResponse2002> {
      const localVarPath = this.basePath + '/test-contexts';
      let queryParameters: any = {};
      let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);

      let requestOptions: AxiosRequestConfig = {
          method: 'GET',
          params: queryParameters,
          headers: headerParams,
          url: localVarPath
      };

      this.authentications.apiAuthorization.applyToRequest(requestOptions);
      this.authentications.default.applyToRequest(requestOptions);

      const deferred:Deferred<InlineResponse2002> = new Deferred<InlineResponse2002>();

      Axios(requestOptions)
      .then((response:AxiosResponse) => {
        if (response.status >= 200 && response.status <= 299){
          deferred.resolve(response.data);
        } else {
          deferred.reject(response);
        }
      })
      .catch((reason) => {
        deferred.reject(reason);
      });
      return deferred.promise;
    }
}

// function isFile(val:any) {
//   return toString.call(val) === '[object File]';
// }

// function isStream(val:any) {
//   return isObject(val) && isFunction(val.pipe);
// }

// function isFunction(val:any) {
//   return toString.call(val) === '[object Function]';
// }

// function isObject(val:any) {
//   return val !== null && typeof val === 'object';
// }

export class Deferred<T> {
	public promise: Promise<T>;

	private fate: "resolved" | "unresolved";
	private state: "pending" | "fulfilled" | "rejected";

	private _resolve: Function;
	private _reject: Function;

	constructor() {
		this.state = "pending";
		this.fate = "unresolved";
		this.promise = new Promise((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;
		});
		this.promise.then(
			() => this.state = "fulfilled",
			() => this.state = "rejected"
		);
	}

	resolve(value?: any) {
		if (this.fate === "resolved") {
			throw "Deferred cannot be resolved twice";
		}
		this.fate = "resolved";
		this._resolve(value);
	}

	reject(reason?: any) {
		if (this.fate === "resolved") {
			throw "Deferred cannot be resolved twice";
		}
		this.fate = "resolved";
		this._reject(reason);
	}

	isResolved() {
		return this.fate === "resolved";
	}

	isPending() {
		return this.state === "pending";
	}

	isFulfilled() {
		return this.state === "fulfilled";
	}

	isRejected() {
		return this.state === "rejected";
	}
}